\section{Recursion (Divide \& Conquer)}
\begin{itemize}
\item Recursion is like Induction's twin brother, whereas induction is similar to movie filmed, and recursion is similar to movie backward.
\item Recursion design may be most important course topic.
\item Recursion is a type of reduction. \footnote{Reduction is to solve problem A using a black box for B. Typically B is smaller.}
\end{itemize}

\subsection{Definition of Recursion: a Powerful type of reduction}
\begin{enumerate}
\item if problem size very small (think $\mathcal{O}(1)$), just solve it.
\item reduce to one or more small instances of some problem.
\end{enumerate}

\question How are the smaller (but not $\mathcal{O}(1)$ size) problem solved?

Not your problem! Handled by the recursion fairy.

\subsection{Tower of Hanoi}
\subsubsection{Description of Problem}
\begin{itemize}
    \item 3 pegs, which hold n distinct sized disks.
    \item initially $tmp$, $dst$ empty and $src$ has all disks sorted.
    \item 3 rules:
    \begin{enumerate}
        \item larger cannot be placed on smaller.
        \item only one disks can move at a time.
        \item move all disks to $dst$.
    \end{enumerate}
\end{itemize}

\question How long until the world end?

\subsubsection{Analysis}
A small hint: not consider the smallest first, but the largest first.

In order to move the largest disk:
\begin{itemize}
    \item $dst$ has to be empty.
    \item $src$ has only largest one.
    \item $tmp$ has $n-1$ disks sorted.
\end{itemize}

So we must:
\begin{enumerate}
    \item move $n-1$ disks from $src$ to $tmp$\tikzmark{hanoi1}{.}
    \item move largest from $src$ to $dst$\tikzmark{hanoi2}{.}
    \item move $n-1$ disk from $tmp$ to $dst$\tikzmark{hanoi3}{.}

    \begin{tikzpicture}[remember picture,overlay,node distance = 3cm]
        \node (hanoi12descr) [right =of hanoi2]{Don't know how to do.};
        \node (hanoi12descrdescr) [below =1cm of hanoi12descr]{\textbf{Don't think about it!!}};
        \draw[red,->,thick] (hanoi1) to [in=-180,out=0] (hanoi12descr);
        \draw[blue,->,thick] (hanoi3) to [in=-180,out=0] (hanoi12descr);
        \draw[purple,->,thick] (hanoi12descr) to [in=90,out=-90] (hanoi12descrdescr);
    \end{tikzpicture}
\end{enumerate}

Don't think about how to move $n-1$ disks, recursion fairy will do it.

\begin{algorithm}[h]
    \caption{Recursive Hanoi}\label{rec_hanoi}
    \begin{algorithmic}
        \Procedure{Hanoi}{$n, src, dst, tmp$}
            \If{$n>0$}
                \State \ProcedureName{Hanoi}{n-1, src, tmp, dst}
                \State Move disk $n$ from $src$ to $dst$.
                \State \ProcedureName{Hanoi}{n-1, tmp, dst, src}
            \EndIf
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

How many moves in \cref{rec_hanoi} ?

Let $T(n)$ be the total moves for $n$ disks.
\begin{align*}
    T(0) &= 0 \\
    T(1) &= 1 \\
    T(n) &= T(n-1) + 1 + T(n-1) \\
         &= 2T(n-1) + 1
\end{align*}

``Solve'' the recurrence.
\[\sum_{l=1}^n 2^{l-1} = 2^n - 1\]

\subsection{Binary Search}

\AlgoInput Given a value $val$, and sorted aray $A[1 \ldots n]$.

\AlgoOutput Is $val$ contained in $A$?

\begin{algorithm}[H]
\caption{Binary Search Algorithm}\label{bianry_search}
\begin{algorithmic}[1]
\Procedure{Bin}{$val, low, high$}
  \If{$high < low$}
    \Return Not Found
  \EndIf
  \State $mid = \big\lfloor\frac{high + low}{2}\big\rfloor$
  \If{$val < A[mid]$}
    \Return \ProcedureName{Bin}{val, low, mid-1}
  \EndIf
  \If{$val > A[mid]$}
    \Return \ProcedureName{Bin}{val,mid+1,high}
  \EndIf
  \Return $mid$
\EndProcedure
\end{algorithmic}
\end{algorithm}

To find whether $val$ is contained in $A[1\ldots n]$, call \ProcedureName{Bin}{val,1,n}.

Let $m = high - low + 1$,

\begin{align}
T(m) & \leq \max\bigg\{T\Big(\Big\lfloor\frac{m-1}{2}\Big\rfloor\Big)\tikzmark{floorceil},
                       T\Big(\Big\lceil\frac{m-1}{2}\Big\rceil\Big)\bigg\}
                       + \Theta(1)\\
     & \leq T\big(\frac{m}{2}\big) + \Theta(1) \\
T(m) & = T\big(\frac{m}{2}\big) + 1 \\
T(m) & = \Theta(1) \text{ for } m = \Theta(1) \tikzmark{notesont}{ }
    \begin{tikzpicture}[remember picture,overlay,node distance = 2cm]
        \node (floorceildescr) [below right =of floorceil, text width=5cm]{\footnotesize{Floor and Ceilings has differences in constant time.}};
        \node (notesontdescr) [below right=1cm and 2cm of notesont, text width=6cm]{\footnotesize{A constant size problem should has a constant solution.}};
        \draw[red,->,thick] (floorceil) to [in=-180,out=-90] (floorceildescr);
        \draw[red,->,thick] (notesont) to [in=-180,out=0] (notesontdescr);
    \end{tikzpicture}
\end{align}

To think the running time in another way:

\begin{align*}
T(m) &= T\Big(\frac{m}{2}\Big) + 1 \\
     &= T\Big(\frac{m}{2\times 2}\Big) + 1 + 1 \\
     &= T\Big(\frac{m}{2\times 2\times 2}\Big) + 1 + 1 + 1
\end{align*}

Counting the number of times divide by 2 to get to 1, i.e.

\[\frac{m}{2^x} = 1 \rightarrow m = 2^x \rightarrow x = \lg{m}\]


\subsection{Maximum Sub-array Sum}

\subsubsection{Description of Problem}

\AlgoInput Given an unsorted array $A[1 \ldots n]$ of integers,
including both negative and positive number.

\AlgoOutput $\displaystyle\max_{i\leq j}\bigg\{\sum_{k=i}^j{A[k]}, 0\bigg\}$.

\subsubsection{Analysis}

\textbf{The Naive Solution}

Let $W[i][j] = \displaystyle\sum_{k=i}^j{A[k]}$ for $i \leq j$.
Return $\max\{0, \max\{W[i][j]\}\}$.
The running time of this brute force solution is$T(n) = \displaystyle\sum_{j=1}^n{\sum_{i=1}^j{(j-i+1)}} = \Theta(n^3)$

\noindent\textbf{Think Recursively!}

Let $maxSum(i,j)$ be the maximum sub-array sum in $A[1 \ldots n]$ or $0$.
The solution is $maxSum(1,n)$.\tikzmark{notesonmaxsum}{ }
\begin{tikzpicture}[remember picture, overlay, node distance = 2cm]
    \node (notesonmaxsumdescr) [below right=0.3cm and 3cm of notesonmaxsum, text width=10cm]{\footnotesize{Can we express $maxSum(1,n)$ in term of $maxSum(1,n-1)$?}};
    \draw[red,->,thick] (notesonmaxsum) to [in=-180,out=0] (notesonmaxsumdescr);
\end{tikzpicture}

There are two cases:

\begin{itemize}
  \item todo.
  \item todo.
\end{itemize}
